# Инженерный аудит проекта teltel

**Дата:** 2024  
**Версия проекта:** v0.3.0  
**Статус фаз:** Phase 1-3 заморожены

---

## 1. Executive Summary

Проект teltel демонстрирует **высокий уровень архитектурной целостности** и соответствия заявленным принципам. Архитектура контрактно-ориентированная, разделение фаз соблюдается, изоляция live-потока от storage реализована корректно.

**Общая оценка:** Система готова к дальнейшему развитию (Phase 4) с учётом выявленных несоответствий.

**Ключевые находки:**
- 3 критических несоответствия (контрактные/документационные)
- 2 предупреждения (документационные)
- 1 замечание (стилистическое)

**Сильные стороны:**
- Чёткое разделение фаз и соблюдение Phase freeze
- Корректная изоляция live-потока от ClickHouse storage
- EventBus используется строго как in-process router
- Payload обрабатывается как opaque (с исключениями для метаданных)
- Система готова к расширению новыми каналами телеметрии

---

## 2. Найденные проблемы

### 2.1 Критические проблемы

#### Проблема #1: Несоответствие пути ingest endpoint

**Тип:** Контрактная / Документационная  
**Критичность:** critical  
**Где обнаружено:**
- `cmd/teltel/main.go:90` — регистрация `/ingest`
- `README.md:54, 154` — документация `/api/ingest`
- `docs/05-ingest-and-storage.md` — документация `/api/ingest`
- `scripts/*.sh` — скрипты используют `/ingest`

**Описание:**
Код регистрирует ingest endpoint как `/ingest`, в то время как документация (README.md и docs/) указывает путь `/api/ingest`. Скрипты используют `/ingest`, что соответствует коду, но не документации.

**Почему это проблема:**
- Нарушает контракт API, заявленный в документации
- Вводит в заблуждение пользователей, следующих документации
- Создаёт несоответствие между документацией и реальным поведением

**Рекомендация:**
Исправить код: изменить регистрацию endpoint в `cmd/teltel/main.go:90` с `/ingest` на `/api/ingest` для соответствия документации. Либо обновить всю документацию на `/ingest` (менее предпочтительно, так как нарушает консистентность с другими API endpoints).

---

#### Проблема #2: Несуществующая функция `lagInFrame` в SQL helpers

**Тип:** Контрактная  
**Критичность:** critical  
**Где обнаружено:**
- `internal/storage/sql_helpers.go:73` — использование `lagInFrame()`
- `docs/11-phase2-design.md:466, 483` — указание, что `lagInFrame` — псевдофункция

**Описание:**
В функции `GetSpikesQuery()` используется функция `lagInFrame()`, которая не существует в ClickHouse. Документация Phase 2 Design указывает, что это псевдофункция и должна использоваться `lag()` с правильным PARTITION BY.

**Почему это проблема:**
- SQL запросы будут падать при выполнении в ClickHouse
- Нарушает контракт SQL helpers как работоспособных запросов
- Противоречит документации Phase 2 Design

**Рекомендация:**
Исправить код: заменить `lagInFrame()` на `lag()` с правильным PARTITION BY в `internal/storage/sql_helpers.go:73`:

```sql
lag(JSONExtractFloat(payload, '%s')) OVER (
  PARTITION BY run_id ORDER BY frame_index
) AS prev_value
```

---

#### Проблема #3: Отсутствие вычисления `total_frames` в метаданных

**Тип:** Контрактная  
**Критичность:** critical  
**Где обнаружено:**
- `internal/storage/metadata.go` — отсутствует вычисление `total_frames`
- `internal/storage/schema.sql:42` — поле `total_frames UInt32` присутствует в схеме
- `docs/11-phase2-design.md` — `total_frames` указан как обязательное поле

**Описание:**
В схеме ClickHouse есть поле `total_frames`, но в `MetadataManager.UpdateFromEvents()` это поле не вычисляется и не заполняется. Вычисляется только `max_frame_index`, но не количество уникальных кадров.

**Почему это проблема:**
- Нарушает контракт схемы данных
- Поле в схеме не используется, что создаёт несоответствие
- Может привести к ошибкам при запросах, ожидающих `total_frames`

**Рекомендация:**
Исправить код: добавить вычисление `total_frames` в `internal/storage/metadata.go`. Необходимо собирать уникальные `frame_index` для каждого run'а и передавать их количество в `upsertMetadata()`.

---

### 2.2 Предупреждения

#### Проблема #4: Парсинг payload в MetadataManager

**Тип:** Архитектурная  
**Критичность:** warning  
**Где обнаружено:**
- `internal/storage/metadata.go:68-78` — парсинг payload для `engine_version` и `seed`
- `internal/storage/metadata.go:93-98` — парсинг payload для `end_reason`

**Описание:**
`MetadataManager` парсит payload событий `run.start` и `run.end` для извлечения метаданных. Это нарушает принцип opaque payload, заявленный в архитектуре.

**Почему это проблема:**
- Нарушает принцип "payload как opaque JSON"
- Создаёт зависимость от структуры payload конкретных типов событий
- Может затруднить эволюцию payload без изменения кода teltel

**Рекомендация:**
Это допустимо для Phase 2, так как метаданные run'ов требуют извлечения информации из payload. Однако это должно быть явно задокументировано как исключение из правила opaque payload. Рекомендуется добавить комментарий в код, объясняющий, почему парсинг payload допустим в этом конкретном случае.

---

#### Проблема #5: Несоответствие имени файла Live UI

**Тип:** Документационная  
**Критичность:** warning  
**Где обнаружено:**
- `README.md:161` — упоминание `/live.html`
- `web/` — файл называется `index.html`, а не `live.html`

**Описание:**
README.md указывает endpoint `GET /live.html`, но в директории `web/` файл называется `index.html`. При этом в `cmd/teltel/main.go:153` используется `mux.Handle("/", fs)`, что означает, что файл доступен как `/index.html`, а не `/live.html`.

**Почему это проблема:**
- Вводит в заблуждение пользователей
- Несоответствие между документацией и реальным поведением

**Рекомендация:**
Исправить документацию: обновить `README.md:161` с `GET /live.html` на `GET /index.html` или `GET /` (в зависимости от реального поведения).

---

### 2.3 Замечания

#### Проблема #6: Channel не проверяется в Validate()

**Тип:** Стилистическая  
**Критичность:** note  
**Где обнаружено:**
- `internal/event/event.go:42-59` — метод `Validate()`
- `docs/03-event-model.md:30` — `channel` указан в структуре события

**Описание:**
Поле `channel` присутствует в структуре события и в документации, но не проверяется в методе `Validate()`. В документации не указано явно, является ли `channel` обязательным полем.

**Почему это замечание:**
- Не критично, так как в документации не указано, что `channel` обязателен
- Может быть намеренным решением для гибкости

**Рекомендация:**
Уточнить в документации `docs/03-event-model.md`, является ли `channel` обязательным полем. Если да — добавить проверку в `Validate()`. Если нет — оставить как есть.

---

## 3. Несоответствия документации

### 3.1 Ingest endpoint путь

**Что заявлено:**
- `POST /api/ingest` (README.md, docs/05-ingest-and-storage.md)

**Что реализовано:**
- `POST /ingest` (cmd/teltel/main.go:90)

**Рекомендация:**
Исправить код: изменить путь на `/api/ingest` для соответствия документации и консистентности с другими API endpoints.

---

### 3.2 SQL функция lagInFrame

**Что заявлено:**
- `lagInFrame` — псевдофункция, в реальности используется `lag()` (docs/11-phase2-design.md:483)

**Что реализовано:**
- Использование `lagInFrame()` в sql_helpers.go:73

**Рекомендация:**
Исправить код: заменить `lagInFrame()` на `lag()` с правильным PARTITION BY.

---

### 3.3 Live UI файл

**Что заявлено:**
- `GET /live.html` (README.md:161)

**Что реализовано:**
- Файл `web/index.html`, доступен через `GET /` или `GET /index.html`

**Рекомендация:**
Исправить документацию: обновить README.md с указанием правильного пути.

---

## 4. Подтверждённые сильные стороны

### 4.1 Архитектурная целостность

✅ **Разделение фаз соблюдается:**
- Phase 1 компоненты (EventBus, Live Buffer, Ingest) не изменялись в Phase 2-3
- Phase 2 компоненты (Batcher, ClickHouse) не влияют на Phase 1
- Phase 3 компоненты (Analysis API) изолированы от live-потока

✅ **Изоляция live-потока от storage:**
- Live Buffer не обращается к ClickHouse
- WebSocket API не использует ClickHouse
- Batcher работает асинхронно и не блокирует live-поток

✅ **EventBus как in-process router:**
- EventBus используется строго для маршрутизации событий
- Нет сетевых зависимостей
- Подписчики изолированы друг от друга

### 4.2 Контрактное соответствие

✅ **Event model:**
- Структура события соответствует документации
- Обязательные поля проверяются в `Validate()`
- Payload хранится как `json.RawMessage` (opaque)

✅ **Ingest контракт:**
- NDJSON формат реализован корректно
- Обработка ошибок соответствует best-effort принципу
- Batch публикация в EventBus реализована

✅ **EventBus контракт:**
- Интерфейс соответствует документации
- Backpressure политики реализованы корректно
- Фильтрация работает согласно спецификации

### 4.3 Расширяемость

✅ **Готовность к новым каналам:**
- Нет жёстко зашитых проверок на конкретные `sourceId`
- `channel` и `type` обрабатываются как строки без ограничений
- EventBus фильтры работают с любыми значениями

✅ **Возможность добавления consumers:**
- EventBus позволяет добавлять новых подписчиков без изменения core
- Интерфейс `Subscription` позволяет создавать любые consumers
- Изоляция подписчиков гарантирует отсутствие взаимного влияния

### 4.4 Failure modes

✅ **Деградация под нагрузкой:**
- Backpressure политики реализованы корректно
- `drop_old` для Live UI предотвращает блокировки
- `block` для Batcher гарантирует сохранность данных
- Изоляция компонентов предотвращает каскадные отказы

---

## 5. Рекомендации

### 5.1 Критические исправления (обязательно)

1. **Исправить путь ingest endpoint:**
   - Изменить `cmd/teltel/main.go:90` с `/ingest` на `/api/ingest`
   - Обновить все скрипты в `scripts/` для использования `/api/ingest`

2. **Исправить SQL функцию в sql_helpers.go:**
   - Заменить `lagInFrame()` на `lag()` в `GetSpikesQuery()`
   - Убедиться, что PARTITION BY корректен

3. **Добавить вычисление total_frames:**
   - Реализовать подсчёт уникальных `frame_index` в `MetadataManager`
   - Заполнять поле `total_frames` в `upsertMetadata()`

### 5.2 Улучшения документации

1. **Уточнить парсинг payload:**
   - Добавить в `docs/05-ingest-and-storage.md` явное указание, что парсинг payload допустим только в `MetadataManager` для метаданных run'ов
   - Добавить комментарий в код `metadata.go`, объясняющий исключение

2. **Исправить упоминание live.html:**
   - Обновить `README.md:161` с указанием правильного пути к Live UI

3. **Уточнить обязательность channel:**
   - В `docs/03-event-model.md` явно указать, является ли `channel` обязательным полем

### 5.3 Архитектурные рекомендации

1. **Сохранить текущую архитектуру:**
   - Разделение фаз работает корректно
   - Изоляция компонентов соблюдается
   - Контракты чётко определены

2. **Подготовка к Phase 4:**
   - Система готова к расширению новыми каналами
   - EventBus позволяет добавлять новых consumers
   - Нет жёстких зависимостей, препятствующих расширению

---

## 6. Заключение

Проект teltel демонстрирует **высокий уровень архитектурной зрелости** и соответствия заявленным принципам. Выявленные проблемы носят в основном документационный характер и не затрагивают архитектурные контракты.

**Критические проблемы** требуют немедленного исправления перед дальнейшим развитием:
- Несоответствие пути ingest endpoint
- Несуществующая SQL функция
- Отсутствие вычисления total_frames

После исправления критических проблем система будет полностью готова к Phase 4 и дальнейшему развитию.

**Общая оценка:** ✅ **Система соответствует архитектурным принципам и готова к расширению с учётом выявленных несоответствий.**

---

## Приложение: Проверенные компоненты

### Кодовая база
- ✅ `cmd/teltel/main.go` — инициализация и роутинг
- ✅ `internal/event/` — Event model и парсинг
- ✅ `internal/eventbus/` — EventBus реализация
- ✅ `internal/ingest/` — Ingest handler
- ✅ `internal/buffer/` — Live Buffer Manager
- ✅ `internal/api/` — HTTP и WebSocket handlers
- ✅ `internal/storage/` — ClickHouse integration
- ✅ `internal/config/` — Конфигурация

### Документация
- ✅ `README.md` — основная документация
- ✅ `docs/02-architecture.md` — архитектура
- ✅ `docs/03-event-model.md` — модель событий
- ✅ `docs/04-eventbus.md` — EventBus контракт
- ✅ `docs/05-ingest-and-storage.md` — Ingest и storage
- ✅ `docs/06-live-ui.md` — Live UI
- ✅ `docs/07-cursor-workflow.md` — Cursor workflow
- ✅ `docs/08-failure-modes.md` — Failure modes
- ✅ `docs/11-phase2-design.md` — Phase 2 design
- ✅ `docs/12-phase3-cursor-examples.md` — Phase 3 examples
- ✅ `docs/PHASE*_FREEZE.md` — Phase freeze документы
- ✅ `ADR/` — Architectural Decision Records
