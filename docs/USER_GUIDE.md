# Руководство пользователя Live UI v2

Это руководство предназначено для **пользователей и интеграторов** Live UI v2. Оно описывает, как настроить систему, запустить сервисы и использовать Live UI для анализа телеметрии в реальном времени.

---

## 1. Введение

### Назначение Live UI

Live UI v2 — это интерактивная система визуализации телеметрии в реальном времени для проекта teltel. Она позволяет:

- **Наблюдать за симуляцией в реальном времени** — графики обновляются автоматически по мере поступления данных
- **Интерактивно анализировать данные** — hover, zoom, pan, time cursor для детального изучения
- **Синхронизировать несколько графиков** — координация времени и интерактивности между графиками
- **Управлять воспроизведением** — play/pause и ручной выбор времени

### Типовые сценарии использования

1. **Отладка симуляции** — наблюдение за поведением системы во время выполнения
2. **Валидация параметров** — проверка корректности работы алгоритмов
3. **Анализ производительности** — отслеживание метрик производительности
4. **Исследование поведения** — изучение динамики системы через интерактивные графики

### Что требуется для работы

- **teltel backend** — сервер для приёма и маршрутизации телеметрии
- **Источник телеметрии** — симулятор или движок, отправляющий события в teltel
- **Live UI** — фронтенд-приложение для визуализации
- **Layout конфигурация** — JSON-файл с описанием структуры UI

---

## 2. Настройка логгера (КРИТИЧЕСКИ ВАЖНО)

Правильная настройка логгера — это основа работы Live UI. Неправильно сформированные события не будут отображаться корректно.

### Обязательные поля события

Каждое событие **должно** содержать следующие поля:

```json
{
  "v": 1,
  "runId": "string",
  "sourceId": "string",
  "channel": "string",
  "type": "string",
  "frameIndex": 0,
  "simTime": 0.0,
  "payload": {}
}
```

#### `v` (версия схемы)

- **Обязательное поле**
- Текущая версия: `1`
- Используется для эволюции формата

#### `runId` (идентификатор run'а)

- **Обязательное поле**
- Уникальный идентификатор запуска симуляции
- Все события одного run'а должны иметь одинаковый `runId`
- Рекомендуется использовать UUID или timestamp-based ID

**Пример:**
```json
"runId": "run-2024-01-15-10-30-45-abc123"
```

#### `sourceId` (источник события)

- **Обязательное поле**
- Идентификатор источника телеметрии
- Рекомендуемые значения: `"flight-engine"`, `"drive-engine"`, `"test-stand"`
- Используется для фильтрации и группировки

#### `channel` (логическая группа)

- **Обязательное поле**
- Логическая группа событий для фильтрации
- Примеры: `"physics"`, `"aero"`, `"drivetrain"`, `"input"`, `"engine"`, `"system"`
- Используется в ChartSpec для выбора данных

#### `type` (тип события)

- **Обязательное поле**
- Тип события, иерархическая нотация через `.`
- Примеры:
  - `"run.start"` — начало run'а
  - `"run.end"` — завершение run'а
  - `"body.state"` — состояние тела
  - `"aero.state"` — аэродинамическое состояние
  - `"frame.start"` — начало кадра
- Используется для фильтрации и визуализации

#### `frameIndex` (индекс кадра)

- **Обязательное поле**
- Целое число, индекс кадра симуляции
- Должно быть неотрицательным: `frameIndex >= 0`
- Монотонно возрастает в рамках одного run'а
- **Основная ось анализа** — используется для синхронизации графиков

#### `simTime` (симуляционное время)

- **Обязательное поле**
- Число с плавающей точкой, симуляционное время в секундах
- Должно быть неотрицательным: `simTime >= 0`
- Монотонно возрастает в рамках одного run'а
- **Вторичная ось анализа** — альтернатива frameIndex

#### `payload` (данные события)

- **Обязательное поле**
- JSON-объект с данными события
- Структура зависит от типа события
- **Не должен содержать текстовых сообщений** — только структурированные данные

### Опциональные поля

#### `wallTimeMs` (время на хосте)

- **Опциональное поле**
- Epoch milliseconds (Unix timestamp)
- Используется для корреляции и отладки
- **Не используется для анализа симуляции**

#### `tags` (теги)

- **Опциональное поле**
- Объект ключ-значение для дополнительной фильтрации
- Примеры:
  ```json
  "tags": {
    "vehicle": "car01",
    "aircraft": "f16",
    "scene": "freeflight"
  }
  ```
- Не должны дублировать данные из `payload`

### Формат сообщений

События отправляются в формате **NDJSON** (Newline Delimited JSON):

- Каждое событие — одна строка JSON
- Строки разделяются символом новой строки (`\n`)
- Content-Type: `application/x-ndjson`

**Пример потока событий:**
```json
{"v":1,"runId":"run-123","sourceId":"flight-engine","channel":"system","type":"run.start","frameIndex":0,"simTime":0.0,"payload":{"version":"1.0.0"}}
{"v":1,"runId":"run-123","sourceId":"flight-engine","channel":"physics","type":"body.state","frameIndex":1,"simTime":0.016,"payload":{"pos":{"x":0,"y":0,"z":100},"vel":{"x":10,"y":0,"z":0}}}
{"v":1,"runId":"run-123","sourceId":"flight-engine","channel":"physics","type":"body.state","frameIndex":2,"simTime":0.032,"payload":{"pos":{"x":0.16,"y":0,"z":100},"vel":{"x":10,"y":0,"z":0}}}
```

### Рекомендации по частоте логирования

#### Time series данные

- **Рекомендуемая частота:** 10-60 Гц (10-60 событий в секунду)
- Для плавной визуализации достаточно 10-20 Гц
- Более высокая частота увеличивает нагрузку на сеть и UI

**Пример для 10 Гц:**
```typescript
// Логирование каждые 100ms
setInterval(() => {
  logger.log({
    channel: 'physics',
    type: 'body.state',
    frameIndex: currentFrame,
    simTime: currentTime,
    payload: { /* данные */ }
  });
}, 100);
```

#### События (events)

- **Логируйте только значимые события**
- Примеры: `run.start`, `run.end`, `frame.start`, `collision`, `warning`
- Не логируйте каждое событие, если их слишком много

#### Warnings / Errors

- **Логируйте все warnings и errors**
- Используйте отдельный `channel`: `"system"` или `"errors"`
- Используйте соответствующий `type`: `"warning"`, `"error"`, `"fatal"`

### Best practices для логирования

#### 1. Структурируйте payload

**Хорошо:**
```json
{
  "payload": {
    "pos": { "x": 0, "y": 0, "z": 100 },
    "vel": { "x": 10, "y": 0, "z": 0 },
    "rot": { "qx": 0, "qy": 0, "qz": 0, "qw": 1 }
  }
}
```

**Плохо:**
```json
{
  "payload": {
    "message": "Position: x=0, y=0, z=100, Velocity: x=10, y=0, z=0"
  }
}
```

#### 2. Используйте консистентные типы событий

- Используйте иерархическую нотацию: `"body.state"`, `"aero.state"`, `"engine.state"`
- Избегайте изменений структуры `payload` для одного `type`
- Документируйте структуру `payload` для каждого типа

#### 3. Генерируйте уникальные runId

**Хорошо:**
```typescript
const runId = `run-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
```

**Плохо:**
```typescript
const runId = "run-1"; // Конфликты при параллельных запусках
```

#### 4. Логируйте run.start и run.end

**Обязательно логируйте:**
- `run.start` в начале run'а с метаданными
- `run.end` в конце run'а с итоговым статусом

**Пример:**
```json
// В начале run'а
{
  "v": 1,
  "runId": "run-123",
  "sourceId": "flight-engine",
  "channel": "system",
  "type": "run.start",
  "frameIndex": 0,
  "simTime": 0.0,
  "payload": {
    "version": "1.0.0",
    "config": { /* конфигурация */ },
    "seed": 12345
  }
}

// В конце run'а
{
  "v": 1,
  "runId": "run-123",
  "sourceId": "flight-engine",
  "channel": "system",
  "type": "run.end",
  "frameIndex": 1000,
  "simTime": 16.0,
  "payload": {
    "status": "completed",
    "reason": "normal"
  }
}
```

### Типичные ошибки при логировании

#### ❌ Отсутствие обязательных полей

**Проблема:**
```json
{
  "runId": "run-123",
  "payload": { "altitude": 100 }
  // Отсутствуют: v, sourceId, channel, type, frameIndex, simTime
}
```

**Решение:** Всегда включайте все обязательные поля.

#### ❌ Неправильный тип данных

**Проблема:**
```json
{
  "frameIndex": "1",  // Должно быть число
  "simTime": "0.016"  // Должно быть число
}
```

**Решение:** Используйте правильные типы данных (числа, а не строки).

#### ❌ Отрицательные frameIndex или simTime

**Проблема:**
```json
{
  "frameIndex": -1,  // Должно быть >= 0
  "simTime": -0.1    // Должно быть >= 0
}
```

**Решение:** Убедитесь, что frameIndex и simTime неотрицательны.

#### ❌ Изменение структуры payload для одного type

**Проблема:**
```json
// Первое событие
{ "type": "body.state", "payload": { "pos": { "x": 0 } } }

// Второе событие
{ "type": "body.state", "payload": { "position": 0 } }  // Разная структура!
```

**Решение:** Сохраняйте консистентную структуру payload для одного type.

#### ❌ Логирование слишком часто

**Проблема:** Логирование на каждом шаге интегратора (1000+ событий в секунду)

**Решение:** Используйте throttling или логируйте только по кадрам.

---

## 3. Запуск сервисов

### Порядок запуска компонентов

1. **Запуск teltel backend** (обязательно первым)
2. **Запуск источника телеметрии** (симулятор/движок)
3. **Запуск Live UI** (опционально, если используется отдельный сервис)

### Запуск teltel backend

#### Локальный запуск (без ClickHouse)

```bash
# Базовый запуск
go run cmd/teltel/main.go

# С указанием порта
go run cmd/teltel/main.go -http-port=8080
```

**Endpoints:**
- Ingest: `http://localhost:8080/api/ingest`
- WebSocket: `ws://localhost:8080/ws`
- Web UI: `http://localhost:8080/`

#### Запуск с ClickHouse (storage + analysis)

```bash
go run cmd/teltel/main.go \
  -clickhouse-url=http://localhost:8123 \
  -batcher-enabled=true \
  -batcher-batch-size=10000 \
  -batcher-flush-interval=500ms
```

#### Docker запуск

```bash
# Запуск всех сервисов (teltel + ClickHouse)
make docker-up

# Или через docker-compose
docker-compose up -d
```

**Доступ:**
- teltel: `http://localhost:8081`
- ClickHouse: `http://localhost:8123`

### Переменные окружения

teltel поддерживает следующие переменные окружения:

- `TELTEL_HTTP_PORT` — порт HTTP сервера (по умолчанию: `8080`)
- `TELTEL_CLICKHOUSE_URL` — URL ClickHouse (например: `http://localhost:8123`)
- `TELTEL_BATCHER_ENABLED` — включить batcher (по умолчанию: `false`)
- `TELTEL_BATCHER_BATCH_SIZE` — размер батча (по умолчанию: `10000`)
- `TELTEL_BATCHER_FLUSH_INTERVAL` — интервал сброса батча (по умолчанию: `500ms`)

**Пример:**
```bash
export TELTEL_HTTP_PORT=8080
export TELTEL_CLICKHOUSE_URL=http://localhost:8123
export TELTEL_BATCHER_ENABLED=true
go run cmd/teltel/main.go
```

### Конфигурационные файлы

teltel не использует конфигурационные файлы — все настройки через переменные окружения или флаги командной строки.

### Запуск Live UI

Live UI может работать в трёх режимах:

1. **Docker (production)** — отдельный сервис в docker-compose (рекомендуется)
2. **Локальная разработка** — Vite dev-сервер для разработки
3. **Legacy (встроенный)** — статические файлы из `web/` директории (устаревший)

#### Docker режим (production, рекомендуется)

Live UI запускается как отдельный сервис в docker-compose:

```bash
# Запуск всего стека (teltel + ClickHouse + live-ui)
make docker-up

# Или через docker-compose
docker-compose up -d
```

**Доступ:** `http://localhost:3000`

**Конфигурация:**
- WebSocket URL настраивается через переменную окружения `VITE_WS_URL` (по умолчанию: `ws://localhost:8081/ws`)
- Конфигурация генерируется автоматически при старте контейнера через `docker-entrypoint.sh`

**Преимущества:**
- ✅ Production-ready сборка (оптимизированный Vite build)
- ✅ Автоматическая конфигурация через environment variables
- ✅ Health checks и зависимости между сервисами
- ✅ Изолированная среда выполнения

#### Локальная разработка (development)

Для разработки и отладки можно запустить Live UI локально:

```bash
cd live-ui

# Установка зависимостей
npm install

# Запуск dev-сервера
npm run dev
```

**Доступ:** `http://localhost:3000`

**Конфигурация:**
- WebSocket URL настраивается через переменную окружения `VITE_WS_URL` (по умолчанию: `ws://localhost:8080/ws`)
- Можно использовать `.env` файл для настройки:
  ```bash
  # .env
  VITE_WS_URL=ws://localhost:8080/ws
  ```

**Преимущества:**
- ✅ Hot-reload для быстрой разработки
- ✅ Source maps для отладки
- ✅ Прямой доступ к исходному коду

#### Legacy режим (встроенный, устаревший)

Старый Live UI доступен через teltel backend:

```bash
# После запуска teltel
open http://localhost:8080
```

**Примечание:** Этот режим устарел. Рекомендуется использовать Docker или локальную разработку.

### Примеры команд запуска

#### Полный стек (Docker)

```bash
# 1. Запуск всего стека (teltel + ClickHouse + live-ui)
make docker-up

# 2. Запуск источника телеметрии (например, flight-engine sandbox)
cd /path/to/flight-engine/sandbox
npm run sandbox

# 3. Откройте Live UI
# http://localhost:3000
```

#### Локальная разработка

```bash
# Терминал 1: teltel backend
go run cmd/teltel/main.go

# Терминал 2: Live UI (для разработки)
cd live-ui
npm run dev

# Терминал 3: источник телеметрии
# (ваш симулятор/движок)

# Откройте Live UI: http://localhost:3000
```

**Примечание:** В локальной разработке Live UI подключается к `ws://localhost:8080/ws` по умолчанию.

---

## 4. Подключение Live UI к данным

### Как Live UI подключается к данным

Live UI подключается к teltel backend через **WebSocket**:

- **Endpoint:** 
  - Docker: `ws://localhost:8081/ws` (внешний порт backend)
  - Локальная разработка: `ws://localhost:8080/ws` (по умолчанию)
- **Протокол:** WebSocket с JSON сообщениями
- **Подписка:** Live UI отправляет запрос на подписку с фильтрами
- **Конфигурация:** WebSocket URL настраивается через переменную окружения `VITE_WS_URL`

**Пример запроса подписки:**
```json
{
  "runId": "run-123",
  "channel": "physics",
  "type": "body.state"
}
```

### Как выбрать run

Run выбирается через:

1. **Layout конфигурация** — `shared_state.selected_run.run_id`
2. **Интерактивный выбор** — через UI компоненты (если реализованы)
3. **Автоматический выбор** — первый активный run

**Пример layout с выбранным run:**
```json
{
  "shared_state": {
    "selected_run": {
      "run_id": "run-123",
      "source": "manual"
    }
  }
}
```

### Как проверить, что данные поступают корректно

#### 1. Проверка WebSocket подключения

В консоли браузера (F12) должны быть сообщения:

```
DataLayer: WebSocket connected
DataLayer: Subscribed to run-123
```

#### 2. Проверка приёма событий

В консоли браузера должны появляться события:

```
DataLayer: Event received { runId: "run-123", type: "body.state", ... }
```

#### 3. Проверка визуализации

- Графики должны обновляться в реальном времени
- Данные должны появляться на графиках
- Time cursor должен двигаться (если включен live mode)

#### 4. Проверка через API

```bash
# Проверка активных run'ов
curl http://localhost:8080/api/runs

# Проверка конкретного run'а
curl http://localhost:8080/api/run?runId=run-123
```

---

## 5. Работа с Live UI

### Обзор интерфейса

Live UI состоит из трёх основных регионов:

1. **Header** — глобальные контролы (run selector, time cursor, play/pause)
2. **Left Panel** — фильтры, список run'ов, настройки видимости (опционально)
3. **Main Panel** — графики в grid layout

### Hover (наведение мыши)

- **Наведение на график** — показывает tooltip с данными ближайшей точки
- **Информация в tooltip:**
  - X и Y значения
  - frameIndex и simTime
  - Дополнительные данные из события

**Использование:**
- Наведите мышь на любой график
- Tooltip появится рядом с курсором
- Tooltip обновляется при движении мыши

### Time Cursor (временной курсор)

Time cursor — это вертикальная линия на графиках, показывающая текущую временную позицию.

**Управление:**
- **Click на графике** — установка time cursor в позицию клика
- **Drag вдоль X-оси** — перемещение time cursor с обновлением в реальном времени
- **Синхронизация** — time cursor синхронизируется между всеми графиками

**Визуализация:**
- Вертикальная красная пунктирная линия
- Отображается на всех синхронизированных графиках

### Zoom & Pan (масштабирование и панорамирование)

**Zoom:**
- **Wheel вверх** — увеличение (zoom in)
- **Wheel вниз** — уменьшение (zoom out)
- Zoom применяется к X и Y осям

**Pan:**
- **Правая кнопка мыши + drag** — панорамирование
- **Ctrl/Cmd + левая кнопка мыши + drag** — панорамирование (альтернатива)
- Pan перемещает видимую область графика

**Reset zoom/pan:**
- Двойной клик на графике (если реализовано)
- Или через кнопку в header (если реализовано)

### Live Control (Play / Pause)

**Play:**
- Автоматическое обновление time cursor
- Time cursor следует за последним frameIndex/simTime из данных
- Обновление каждые 100ms

**Pause:**
- Фиксация time cursor
- Остановка автоматических обновлений

**Использование:**
- Кнопка Play/Pause в header
- При ручном изменении time cursor (click/drag) автоматически ставится на pause

### Time Scrubbing (ручной выбор времени)

**TimeScrubber** — это slider в header для выбора времени.

**Использование:**
- Перемещение slider → обновление time cursor
- Отображение текущего frameIndex/simTime
- Отображение min/max диапазона

**Интеграция с live mode:**
- При ручном scrubbing → автоматический pause
- При play → slider следует за автоматическим time cursor

### Синхронизация графиков

Графики могут быть синхронизированы через `shared_state.time_cursor.sync_across`:

**Синхронизация time cursor:**
- Изменение в одном графике → обновление во всех синхронизированных
- Визуальный курсор совпадает на всех графиках

**Синхронизация hover (опционально):**
- Hover на одном графике может синхронизироваться с другими

**Синхронизация zoom/pan (опционально):**
- Zoom/pan на одном графике может применяться к синхронизированным

### Типовые аналитические сценарии

#### Сценарий 1: Отладка поведения системы

1. Запустите симуляцию
2. Откройте Live UI
3. Выберите run в header
4. Наблюдайте за графиками в реальном времени
5. При обнаружении аномалии:
   - Нажмите Pause
   - Используйте zoom для детального изучения
   - Используйте hover для точных значений

#### Сценарий 2: Анализ конкретного момента времени

1. Запустите симуляцию
2. Используйте TimeScrubber для выбора времени
3. Или кликните на графике для установки time cursor
4. Изучите все графики на выбранном моменте времени
5. Используйте hover для получения точных значений

#### Сценарий 3: Сравнение разных каналов

1. Настройте layout с несколькими графиками
2. Каждый график показывает разные channel или type
3. Используйте синхронизацию time cursor
4. Сравнивайте поведение разных каналов на одном моменте времени

---

## 6. Диагностика и отладка

### Как понять, что данные не приходят

#### Проверка 1: WebSocket подключение

**Симптомы:**
- Графики пустые
- В консоли ошибки подключения

**Диагностика:**
1. Откройте консоль браузера (F12)
2. Проверьте сообщения:
   ```
   DataLayer: WebSocket connecting to ws://localhost:8080/ws
   DataLayer: WebSocket connected
   ```

**Решение:**
- Убедитесь, что teltel backend запущен
- Проверьте URL WebSocket:
  - Docker: `ws://localhost:8081/ws` (внешний порт)
  - Локальная разработка: `ws://localhost:8080/ws`
- Проверьте переменную окружения `VITE_WS_URL` (если используется)
- Проверьте, что порт не заблокирован файрволом

#### Проверка 2: Подписка на события

**Симптомы:**
- WebSocket подключен, но события не приходят

**Диагностика:**
1. Проверьте запрос подписки в консоли:
   ```
   DataLayer: Subscribed to { runId: "run-123", channel: "physics" }
   ```
2. Проверьте, что runId существует:
   ```bash
   curl http://localhost:8080/api/runs
   ```

**Решение:**
- Убедитесь, что runId корректный
- Проверьте, что события отправляются с правильными runId, channel, type

#### Проверка 3: Валидация событий

**Симптомы:**
- События приходят, но не отображаются на графиках

**Диагностика:**
1. Проверьте консоль на ошибки валидации:
   ```
   DataLayer: Invalid event: missing field 'frameIndex'
   ```
2. Проверьте структуру событий через API:
   ```bash
   curl http://localhost:8080/api/run?runId=run-123
   ```

**Решение:**
- Убедитесь, что все обязательные поля присутствуют
- Проверьте типы данных (frameIndex и simTime должны быть числами)

### Как проверить корректность логгера

#### Проверка 1: Структура событий

**Проверьте обязательные поля:**
```json
{
  "v": 1,                    // ✅ Присутствует
  "runId": "run-123",       // ✅ Присутствует и не пустой
  "sourceId": "flight-engine", // ✅ Присутствует
  "channel": "physics",      // ✅ Присутствует
  "type": "body.state",     // ✅ Присутствует
  "frameIndex": 1,          // ✅ Присутствует и >= 0
  "simTime": 0.016,         // ✅ Присутствует и >= 0
  "payload": {}             // ✅ Присутствует
}
```

#### Проверка 2: Формат NDJSON

**Проверьте формат отправки:**
- Каждое событие — одна строка JSON
- Строки разделяются `\n`
- Content-Type: `application/x-ndjson`

**Пример правильного формата:**
```
{"v":1,"runId":"run-123",...}\n
{"v":1,"runId":"run-123",...}\n
```

#### Проверка 3: Частота логирования

**Проверьте частоту:**
- Time series: 10-60 Гц (рекомендуется 10-20 Гц)
- События: только значимые события
- Не логируйте слишком часто (может перегрузить систему)

### Типичные проблемы и их решения

#### Проблема 1: Графики не обновляются

**Возможные причины:**
1. WebSocket не подключен
2. События не приходят
3. Неправильные фильтры в ChartSpec
4. Window logic скрывает данные

**Решение:**
1. Проверьте WebSocket подключение в консоли
2. Проверьте, что события отправляются с правильными runId, channel, type
3. Проверьте ChartSpec фильтры
4. Проверьте window настройки (может быть слишком маленький)

#### Проблема 2: Time cursor не синхронизируется

**Возможные причины:**
1. Графики не в одной группе синхронизации
2. Разные axis (frameIndex vs simTime)
3. Ошибка в shared_state конфигурации

**Решение:**
1. Проверьте `shared_state.time_cursor.sync_across` в layout
2. Убедитесь, что все графики используют одинаковый axis
3. Проверьте консоль на ошибки

#### Проблема 3: Tooltip не появляется

**Возможные причины:**
1. Hover не обрабатывается
2. Данные отсутствуют в точке hover
3. Ошибка в компоненте TooltipLayer

**Решение:**
1. Проверьте, что данные присутствуют на графике
2. Проверьте консоль на ошибки
3. Убедитесь, что график поддерживает hover

#### Проблема 4: Zoom/Pan не работает

**Возможные причины:**
1. Конфликт с time cursor (pan работает только с правой кнопкой мыши)
2. Ошибка в обработке событий
3. График не поддерживает zoom/pan

**Решение:**
1. Используйте правую кнопку мыши для pan
2. Проверьте консоль на ошибки
3. Убедитесь, что график поддерживает интерактивность

---

## 7. Ограничения и рекомендации

### Что Live UI делает

✅ **Визуализация в реальном времени** — графики обновляются автоматически  
✅ **Интерактивный анализ** — hover, zoom, pan, time cursor  
✅ **Синхронизация графиков** — координация времени и интерактивности  
✅ **Управление воспроизведением** — play/pause, time scrubbing  
✅ **Декларативная конфигурация** — структура UI через JSON

### Что Live UI не делает

❌ **Сравнение нескольких run'ов** — планируется в Stage 8  
❌ **Анализ завершённых run'ов** — используйте Analysis UI (`analysis.html`)  
❌ **Экспорт данных** — данные доступны через API  
❌ **Автоматический анализ** — только визуализация и интерактивность

### Рекомендации по масштабированию

#### Частота событий

- **Рекомендуется:** 10-20 Гц для time series
- **Максимум:** 60 Гц (может перегрузить UI при большом количестве графиков)
- **Для событий:** только значимые события

#### Количество графиков

- **Рекомендуется:** 4-8 графиков на экране
- **Максимум:** зависит от производительности браузера
- **Оптимизация:** используйте window logic для ограничения данных

#### Размер window

- **Рекомендуется:** 1000-5000 кадров для time series
- **Для scatter:** зависит от количества точек
- **Для histogram:** автоматический пересчёт

### Рекомендации по производительности

#### Оптимизация рендеринга

- Используйте window logic для ограничения данных
- Избегайте слишком частых обновлений (throttle события)
- Используйте синхронизацию только когда необходимо

#### Оптимизация памяти

- Window logic автоматически удаляет старые данные
- Настройте window size в зависимости от доступной памяти
- Избегайте хранения всех данных в памяти

#### Оптимизация сети

- Используйте фильтры в подписке WebSocket
- Логируйте только необходимые события
- Используйте throttling для высокочастотных данных

---

## Ссылки

- [Архитектурный документ](../LIVE_UI_ARCHITECTURE_DESIGN.md)
- [Статус реализации](../live-ui/IMPLEMENTATION_STATUS.md)
- [Event Model](./03-event-model.md)
- [Roadmap дальнейшего развития](./ROADMAP_NEXT.md)
