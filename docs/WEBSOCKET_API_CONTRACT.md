# WebSocket API Contract v1

Документ описывает контракт WebSocket API между backend (teltel) и frontend (Live UI v2).

**Версия:** 1.0  
**Дата создания:** 2024  
**Статус:** Актуальный

---

## 1. Обзор

WebSocket API используется для передачи live-потока телеметрических событий от backend к UI.

### 1.1 Endpoint

- **URL:** `ws://<host>:<port>/ws`
- **Протокол:** WebSocket (RFC 6455)
- **Формат сообщений:** JSON

### 1.2 Назначение

- Подписка на поток событий в реальном времени
- Фильтрация событий по критериям (runId, sourceId, channel, type, tags)
- Обработка backpressure через policy `drop_old`

### 1.3 Версионирование

Контракт версионируется через поле `v` в структуре Event. Текущая версия контракта: **v1**.

---

## 2. Протокол подключения

### 2.1 Последовательность подключения

1. **Клиент открывает WebSocket соединение**
   - URL: `ws://<host>:<port>/ws`
   - Протокол: WebSocket (без подпротоколов)

2. **После установления соединения (onopen)**
   - Клиент отправляет `WSRequest` (JSON) для подписки
   - Сервер читает запрос и создаёт подписку на EventBus

3. **Сервер начинает отправлять события**
   - Поток `Event` объектов (JSON, по одному на сообщение)
   - События соответствуют фильтру из `WSRequest`

4. **Keepalive**
   - Сервер отправляет ping каждые 54 секунды
   - Клиент должен отвечать pong (автоматически)
   - Timeout: 60 секунд без pong → закрытие соединения

5. **Закрытие соединения**
   - Клиент может закрыть соединение в любой момент
   - Сервер закрывает подписку при отключении клиента
   - При закрытии сервер отправляет WebSocket close frame

### 2.2 Параметры соединения

**Сервер:**
- `writeWait`: 10 секунд (таймаут записи)
- `pongWait`: 60 секунд (таймаут ожидания pong)
- `pingPeriod`: 54 секунды (период отправки ping)
- `maxMessageSize`: 512 байт (максимальный размер входящего сообщения)
- `ReadBufferSize`: 1024 байт
- `WriteBufferSize`: 1024 байт

**Backpressure policy:**
- Всегда `drop_old` для UI клиентов
- Buffer size: 2048 событий
- При переполнении буфера старые события отбрасываются

---

## 3. Структуры данных

### 3.1 WSRequest (запрос на подписку)

Запрос от клиента на подписку на события.

```typescript
interface WSRequest {
  runId?: string;           // Фильтр по runId
  sourceId?: string;         // Фильтр по sourceId
  channel?: string;          // Фильтр по channel
  types?: string[];          // Фильтр по типам событий
  tags?: Record<string, string>; // Фильтр по тегам (все теги должны совпадать)
}
```

**Поля:**

- `runId` (опционально) — идентификатор run'а. Если указан, возвращаются только события этого run'а.
- `sourceId` (опционально) — идентификатор источника (например, `"flight-engine"`, `"drive-engine"`).
- `channel` (опционально) — логическая группа событий (например, `"physics"`, `"aero"`).
- `types` (опционально) — массив типов событий. Если указан, возвращаются только события с указанными типами.
- `tags` (опционально) — объект с тегами. Все указанные теги должны присутствовать в событии (AND логика).

**Логика фильтрации:**

- Все указанные поля применяются как AND (все условия должны выполняться)
- Если поле не указано, фильтр по нему не применяется
- Пустой `WSRequest` (все поля опциональны) вернёт все события

**Примеры:**

```json
// Подписка на все события конкретного run'а
{
  "runId": "run-123"
}

// Подписка на события physics канала
{
  "channel": "physics"
}

// Подписка на события конкретного типа
{
  "types": ["body.state", "aero.state"]
}

// Комбинированный фильтр
{
  "runId": "run-123",
  "channel": "physics",
  "types": ["body.state"],
  "tags": {
    "vehicle": "car01"
  }
}
```

### 3.2 Event (событие)

Структура телеметрического события.

```typescript
interface Event {
  v: number;                        // Версия схемы (обязательно)
  runId: string;                    // Идентификатор run'а (обязательно)
  sourceId: string;                  // Идентификатор источника (обязательно)
  channel: string;                   // Логическая группа (обязательно)
  type: string;                     // Тип события (обязательно)
  frameIndex: number;               // Индекс кадра (обязательно, >= 0)
  simTime: number;                  // Симуляционное время в секундах (обязательно, >= 0)
  wallTimeMs?: number | null;       // Время на хосте в миллисекундах (опционально)
  tags?: Record<string, string>;    // Произвольные теги (опционально)
  payload: unknown;                 // JSON payload события (обязательно)
}
```

**Поля:**

- `v` (обязательно) — версия схемы события. Текущая версия: `1`.
- `runId` (обязательно) — идентификатор запуска симуляции. Все события одного run'а имеют одинаковый `runId`.
- `sourceId` (обязательно) — идентификатор источника события (например, `"flight-engine"`, `"drive-engine"`).
- `channel` (обязательно) — логическая группа событий (например, `"physics"`, `"aero"`, `"drivetrain"`).
- `type` (обязательно) — тип события (например, `"run.start"`, `"frame.start"`, `"body.state"`).
- `frameIndex` (обязательно) — индекс кадра симуляции. Целое число, монотонно возрастает, >= 0.
- `simTime` (обязательно) — симуляционное время в секундах. Число с плавающей точкой, монотонно возрастает, >= 0.
- `wallTimeMs` (опционально) — время на хосте в миллисекундах (epoch time). Используется для корреляции и отладки, не используется для анализа симуляции.
- `tags` (опционально) — произвольные теги для фильтрации. Объект ключ-значение.
- `payload` (обязательно) — данные события в формате JSON. Структура зависит от типа события.

**Инварианты:**

- `frameIndex` и `simTime` обязательны для всех кадровых событий
- `payload` не должен изменять форму для одного `type`
- Отсутствие события допустимо
- Дублирование событий допустимо

**Примеры:**

```json
// Событие начала run'а
{
  "v": 1,
  "runId": "run-123",
  "sourceId": "flight-engine",
  "channel": "system",
  "type": "run.start",
  "frameIndex": 0,
  "simTime": 0.0,
  "wallTimeMs": 1730000000000,
  "tags": {
    "vehicle": "f16",
    "scene": "freeflight"
  },
  "payload": {
    "engine_version": "1.0.0",
    "seed": 12345,
    "config": { ... }
  }
}

// Событие состояния тела
{
  "v": 1,
  "runId": "run-123",
  "sourceId": "flight-engine",
  "channel": "physics",
  "type": "body.state",
  "frameIndex": 100,
  "simTime": 1.67,
  "wallTimeMs": 1730000000167,
  "payload": {
    "position": { "x": 100.0, "y": 50.0, "z": 1000.0 },
    "velocity": { "x": 50.0, "y": 0.0, "z": 0.0 },
    "orientation": { ... }
  }
}
```

---

## 4. Обработка ошибок

### 4.1 Ошибки подключения

**Сценарий:** Не удалось установить WebSocket соединение

- **Клиент:** Обрабатывает через `onerror` или `onclose`
- **Сервер:** Логирует ошибку, закрывает соединение
- **Действие клиента:** Рекомендуется retry с экспоненциальной задержкой

**Сценарий:** Неверный URL или порт недоступен

- **Клиент:** WebSocket не может установить соединение
- **Сервер:** Не получает запрос
- **Действие клиента:** Проверить конфигурацию URL

### 4.2 Ошибки запроса (WSRequest)

**Сценарий:** Неверный формат WSRequest (не JSON)

- **Сервер:** Логирует ошибку, закрывает соединение
- **Клиент:** Получает `onclose` без кода ошибки
- **Действие клиента:** Проверить формат отправляемого JSON

**Сценарий:** WSRequest не отправлен в течение таймаута

- **Сервер:** Закрывает соединение по таймауту чтения
- **Клиент:** Получает `onclose`
- **Действие клиента:** Убедиться, что WSRequest отправляется сразу после `onopen`

### 4.3 Ошибки подписки (EventBus)

**Сценарий:** Ошибка создания подписки на EventBus

- **Сервер:** Логирует ошибку, закрывает соединение
- **Клиент:** Получает `onclose`
- **Действие клиента:** Проверить логи сервера, повторить подключение

### 4.4 Ошибки отправки событий

**Сценарий:** Ошибка записи события в WebSocket

- **Сервер:** Логирует ошибку, закрывает соединение
- **Клиент:** Получает `onclose`
- **Действие клиента:** Переподключиться

**Сценарий:** Клиент не отвечает на ping (timeout)

- **Сервер:** Закрывает соединение по таймауту pong (60 секунд)
- **Клиент:** Получает `onclose`
- **Действие клиента:** Проверить сетевые условия, переподключиться

### 4.5 Ошибки парсинга на клиенте

**Сценарий:** Неверный формат Event (не JSON)

- **Клиент:** Обрабатывает через `onError` callback
- **Действие клиента:** Логировать ошибку, продолжить работу (игнорировать сообщение)

**Сценарий:** Event не соответствует схеме

- **Клиент:** Валидирует через `validateEvent()`, обрабатывает через `onError`
- **Действие клиента:** Логировать ошибку, игнорировать событие

### 4.6 Рекомендации по обработке ошибок

**Клиент должен:**

1. Обрабатывать все типы ошибок через callbacks (`onError`, `onclose`)
2. Реализовать retry логику с экспоненциальной задержкой
3. Логировать ошибки для отладки
4. Показывать пользователю статус подключения
5. Валидировать входящие события перед обработкой

**Сервер должен:**

1. Логировать все ошибки
2. Корректно закрывать соединения при ошибках
3. Закрывать подписки EventBus при отключении клиента
4. Обрабатывать таймауты (ping/pong)

---

## 5. Примеры использования

### 5.1 Базовое подключение (JavaScript/TypeScript)

```typescript
// Создание WebSocket соединения
const ws = new WebSocket('ws://localhost:8080/ws');

// Отправка запроса на подписку после открытия
ws.onopen = () => {
  const request: WSRequest = {
    runId: 'run-123',
    channel: 'physics',
    types: ['body.state']
  };
  ws.send(JSON.stringify(request));
};

// Обработка входящих событий
ws.onmessage = (event) => {
  try {
    const data: Event = JSON.parse(event.data);
    console.log('Received event:', data);
    // Обработка события
  } catch (error) {
    console.error('Failed to parse event:', error);
  }
};

// Обработка ошибок
ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};

ws.onclose = () => {
  console.log('WebSocket closed');
};
```

### 5.2 Использование WSClient (Live UI)

```typescript
import { WSClient } from './data/websocket';
import type { Event, WSRequest } from './data/types';

const client = new WSClient(
  {
    onEvent: (event: Event) => {
      console.log('Event received:', event);
      // Обработка события
    },
    onStateChange: (state) => {
      console.log('Connection state:', state);
    },
    onError: (error) => {
      console.error('Error:', error);
    }
  },
  {
    url: 'ws://localhost:8080/ws',
    reconnect: true,
    reconnectDelay: 1000,
    maxReconnectAttempts: 10
  }
);

// Подключение с фильтром
const request: WSRequest = {
  runId: 'run-123',
  channel: 'physics'
};

client.connect(request);

// Обновление подписки
client.updateSubscription({
  runId: 'run-123',
  channel: 'aero'
});

// Закрытие соединения
client.disconnect();
```

### 5.3 Фильтрация по runId

```typescript
const request: WSRequest = {
  runId: 'run-123'
};

client.connect(request);
// Получаем все события run'а 'run-123'
```

### 5.4 Фильтрация по channel и type

```typescript
const request: WSRequest = {
  channel: 'physics',
  types: ['body.state', 'body.force']
};

client.connect(request);
// Получаем только события physics канала типов body.state и body.force
```

### 5.5 Фильтрация по тегам

```typescript
const request: WSRequest = {
  tags: {
    vehicle: 'car01',
    scene: 'freeflight'
  }
};

client.connect(request);
// Получаем события, у которых есть оба тега: vehicle=car01 и scene=freeflight
```

### 5.6 Комбинированный фильтр

```typescript
const request: WSRequest = {
  runId: 'run-123',
  sourceId: 'flight-engine',
  channel: 'physics',
  types: ['body.state'],
  tags: {
    vehicle: 'f16'
  }
};

client.connect(request);
// Получаем события, которые соответствуют всем критериям
```

---

## 6. Ограничения и гарантии

### 6.1 Гарантии доставки

- **Нет гарантии доставки:** События могут быть потеряны при переполнении буфера (policy `drop_old`)
- **Best-effort порядок:** События отправляются в порядке поступления, но порядок не гарантирован
- **Дублирование допустимо:** Одно и то же событие может быть отправлено несколько раз

### 6.2 Производительность

- **Backpressure:** При переполнении буфера (2048 событий) старые события отбрасываются
- **Latency:** Задержка зависит от сетевых условий и нагрузки на сервер
- **Throughput:** Максимальная пропускная способность ограничена размером буфера и сетью

### 6.3 Масштабирование

- **Один клиент = одна подписка:** Каждое WebSocket соединение создаёт отдельную подписку на EventBus
- **Несколько клиентов:** Каждый клиент получает независимый поток событий
- **Ресурсы:** Каждое соединение потребляет память (буфер 2048 событий) и CPU

### 6.4 Безопасность

- **CORS:** В текущей версии разрешены все origin (для локального использования)
- **Аутентификация:** Не реализована (для будущих версий)
- **Авторизация:** Не реализована (для будущих версий)

---

## 7. Версионирование и обратная совместимость

### 7.1 Версионирование контракта

Контракт версионируется через поле `v` в структуре Event:

- **v1** (текущая версия) — описан в этом документе
- **v2+** (будущие версии) — будут документированы отдельно

### 7.2 Обратная совместимость

- **Добавление новых полей:** Новые опциональные поля в Event не ломают старых клиентов
- **Удаление полей:** Удаление полей считается breaking change
- **Изменение типов:** Изменение типов полей считается breaking change
- **Изменение протокола:** Изменение протокола подключения считается breaking change

### 7.3 Миграция на новые версии

При миграции на новую версию контракта:

1. Обновить документацию контракта
2. Обновить версию в Event (`v` поле)
3. Обновить клиентов для поддержки новой версии
4. Обеспечить обратную совместимость (если возможно)

---

## 8. Тестирование

### 8.1 Валидация контракта

Для валидации соответствия контракту рекомендуется:

1. **Валидация WSRequest:** Проверка структуры запроса на стороне сервера
2. **Валидация Event:** Проверка структуры события на стороне клиента
3. **Интеграционные тесты:** Тесты полного цикла подключения и передачи событий
4. **Нагрузочное тестирование:** Проверка поведения при высокой нагрузке

### 8.2 Примеры тестов

```typescript
// Тест подключения и получения событий
describe('WebSocket API', () => {
  it('should connect and receive events', async () => {
    const client = new WSClient({
      onEvent: (event) => {
        expect(event.v).toBe(1);
        expect(event.runId).toBeDefined();
        expect(event.frameIndex).toBeGreaterThanOrEqual(0);
      }
    });

    client.connect({ runId: 'test-run' });
    // ... ожидание событий
  });
});
```

---

## 9. Troubleshooting

### 9.1 Проблемы подключения

**Проблема:** WebSocket не подключается

- Проверить URL (должен быть `ws://` или `wss://`)
- Проверить доступность сервера
- Проверить CORS настройки (для браузера)
- Проверить логи сервера

**Проблема:** Соединение закрывается сразу после открытия

- Проверить, что WSRequest отправляется сразу после `onopen`
- Проверить формат WSRequest (должен быть валидный JSON)
- Проверить логи сервера на ошибки подписки

### 9.2 Проблемы с событиями

**Проблема:** События не приходят

- Проверить фильтр в WSRequest (возможно, слишком строгий)
- Проверить, что события генерируются на сервере
- Проверить логи сервера

**Проблема:** События приходят с задержкой

- Проверить нагрузку на сервер
- Проверить сетевые условия
- Проверить размер буфера (2048 событий)

**Проблема:** События теряются

- Это нормальное поведение при policy `drop_old`
- Увеличить размер буфера (требует изменения на сервере)
- Использовать другой backpressure policy (не рекомендуется для UI)

### 9.3 Проблемы с парсингом

**Проблема:** Ошибка парсинга JSON

- Проверить формат входящих сообщений
- Проверить кодировку (должна быть UTF-8)
- Проверить логи сервера на ошибки сериализации

**Проблема:** Event не проходит валидацию

- Проверить структуру Event (все обязательные поля)
- Проверить типы полей (frameIndex и simTime должны быть числами)
- Проверить версию схемы (`v` поле)

---

## 10. Ссылки

### 10.1 Документация проекта

- [Event Model](docs/03-event-model.md) — описание модели событий
- [EventBus](docs/04-eventbus.md) — описание EventBus
- [LIVE_UI_ARCHITECTURE_DESIGN.md](LIVE_UI_ARCHITECTURE_DESIGN.md) — архитектура Live UI
- [STANDALONE_LIVE_UI_2_SERVICE_ROADMAP.md](STANDALONE_LIVE_UI_2_SERVICE_ROADMAP.md) — roadmap выделения UI в сервис

### 10.2 Внешние ресурсы

- [WebSocket RFC 6455](https://tools.ietf.org/html/rfc6455)
- [Gorilla WebSocket](https://github.com/gorilla/websocket) — библиотека WebSocket для Go

---

**Документ создан:** 2024  
**Версия контракта:** 1.0  
**Статус:** Актуальный
